#!/usr/bin/env stap
#
# https://s2e.systems/docs/Tutorials/SystemTap/index.html
# https://sourceware.org/systemtap/documentation.html
#

%{
#include <linux/skbuff.h>

struct DemoHeader {
    uint16_t seed; // egress port
    uint16_t len;  // payload length
};
%}


global prog_name="demo-r1"

#
# S2E functions.
# We use the embedded C support of SystemTap to access the S2E custom
# instructions. A comprehensive set of such instructions can be found in
# src/s2e/guest/common/include/s2e/s2e.h.
#

/**
 * Print a message to the S2E log.
 */
private function s2e_message(message:string) %{ /* unprivileged */
    __asm__ __volatile__(
            ".byte 0x0f, 0x3f\n"
            ".byte 0x00, 0x10, 0x00, 0x00\n"
            ".byte 0x00, 0x00, 0x00, 0x00\n"
            : : "a" (STAP_ARG_message));
%}

/**
 * Fill a buffer with unconstrained symbolic values.
 */
private function s2e_make_symbolic(buf:long, size:long, name:string) %{
    void *_buf = (void *)STAP_ARG_buf;
    int _size = STAP_ARG_size;
    __asm__ __volatile__(
            ".byte 0x0f, 0x3f\n"
            ".byte 0x00, 0x03, 0x00, 0x00\n"
            ".byte 0x00, 0x00, 0x00, 0x00\n"
            : : "a" (_buf), "d" (_size), "c" (STAP_ARG_name) : "memory");
%}

/**
 * Terminate the current state.
 */
private function s2e_kill_state(status:long, message:string) %{
    __asm__ __volatile__(
            ".byte 0x0f, 0x3f\n"
            ".byte 0x00, 0x06, 0x00, 0x00\n"
            ".byte 0x00, 0x00, 0x00, 0x00\n"
            : : "a" ((uint32_t)STAP_ARG_status), "d" (STAP_ARG_message));
%}

/**
 * Set `intf` and `buffer` to be symbolic.
 *
 * References:
 *   src/s2e/guest/common/include/s2e/s2e.h
 *   src/s2e/guest/common/include/s2e/opcodes.h
 */

private function s2e_mimesis_kernel_recv(intf:long, buffer:long, len:long) %{
    __asm__ __volatile__(
        ".byte 0x0F, 0x3F\n"
        ".byte 0x00, 0x99, 0x02, 0x00\n"
        ".byte 0x00, 0x00, 0x00, 0x00\n"
        : : "a" (STAP_ARG_intf), "c" (STAP_ARG_buffer), "d" (STAP_ARG_len) : "memory"
    );
%}

private function s2e_mimesis_kernel_send(intf:long, buffer:long, len:long) %{
    __asm__ __volatile__(
        ".byte 0x0F, 0x3F\n"
        ".byte 0x00, 0x99, 0x03, 0x00\n"
        ".byte 0x00, 0x00, 0x00, 0x00\n"
        : : "a" (STAP_ARG_intf), "c" (STAP_ARG_buffer), "d" (STAP_ARG_len) : "memory"
    );
%}


#
# Helper functions.
#

/**
 * Print the given message to both the standard output and S2E log.
 */
private function info(message:string) {
    printf("%s: [%s:%s] %s\n", probefunc(), pstrace(pid2task(pid())), execname(), message);
    msg = sprintf("%s: [%s:%s] %s\n", probefunc(), pstrace(pid2task(pid())), execname(), message);
    s2e_message(msg);
}

/**
 * Check whether the mac_header field of the given sk_buff is set.
 * https://elixir.bootlin.com/linux/v4.9.3/source/include/linux/skbuff.h#L2172
 */
private function skb_mac_header_was_set:long(skb:long) %{ /* pure */
    struct sk_buff *skb = (struct sk_buff *)STAP_ARG_skb;
    uint16_t mac_header = kread(&(skb->mac_header));
    STAP_RETURN(mac_header != (typeof(mac_header))~0U);
%}

/**
 * Get the Ethernet header of the given sk_buff.
 * https://elixir.bootlin.com/linux/v4.9.3/source/include/linux/skbuff.h#L2167
 */
private function skb_mac_header:long(skb:long) { /* pure */
    return @cast(skb, "sk_buff")->head + @cast(skb, "sk_buff")->mac_header;
}

/**
 * Check whether the given Ethernet address is magical.
 */
private function check_eth_addr:long(eth_addr:long) %{ /* pure */
    uint8_t id_mac[6] = { 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF };
    STAP_RETURN(memcmp((uint8_t *)STAP_ARG_eth_addr, id_mac, 6) == 0);
%}


#
# Ingress probes.
#

/**
 * static int __netif_receive_skb_core(struct sk_buff **pskb, bool pfmemalloc, struct packet_type **ppt_prev) (kernel 6.8.2)
 * $skb is a local variable that is not initialized at the moment the probe is triggered
 * The following probe is inside the function __netif_receive_skb_list_core, after the execution of __netif_receive_skb_core.
 */
probe kernel.statement("*@net/core/dev.c:5621") {
    if(execname() == prog_name)
    {
        skb_ptr=$skb;
        // eth_hdr = skb_mac_header(skb_ptr);
        // eth_dst_addr = @cast(eth_hdr, "ethhdr")->h_dest;
        // ethertype = ntohs(@cast(eth_hdr, "ethhdr")->h_proto);

        ifindex_ptr = &@cast(skb_ptr, "sk_buff")->dev->ifindex;
        msg = sprintf("__netif_receive_skb_core:5621");
        info(msg);
        s2e_mimesis_kernel_recv(ifindex_ptr, @cast(skb_ptr, "sk_buff")->data, @cast(skb_ptr, "sk_buff")->len);
    }
}


#
# Egress probes.
#

/**
 * Accessing $skb at __netdev_start_xmit or netdev_start_xmit gives an error, although $skb is a parameter for both in kernel 6.8.2.
 * Links that might be relevant to this:
 * https://man7.org/linux/man-pages/man7/error::pass2.7stap.html
 * https://bugzilla.redhat.com/show_bug.cgi?id=1734097
 *
 * Therefore I am probing xmit_one:
 * static int xmit_one(struct sk_buff *skb, struct net_device *dev, struct netdev_queue *txq, bool more)
 */

probe kernel.function("xmit_one") {
    if(execname() == prog_name)
    {
        // eth_hdr = skb_mac_header($skb);
        // eth_dst_addr = @cast(eth_hdr, "ethhdr")->h_dest;
        // ethertype = ntohs(@cast(eth_hdr, "ethhdr")->h_proto);

        ifindex_ptr = &$skb->dev->ifindex;
        msg = sprintf("xmit_one");
        info(msg);
        msg = sprintf("len=%d head=%x header_len=%d data=%x data_len=%d mac=%x mac_len=%d",$skb->len, $skb->head, $skb->hdr_len, $skb->data, $skb->data_len, $skb->mac_header, $skb->mac_len);
        info(msg);
        s2e_mimesis_kernel_send(ifindex_ptr, $skb->data, $skb->len);
    }
}

# vim: ts=4 sw=4 et cms=#%s :
