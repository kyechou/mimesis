#!/usr/bin/env stap
#
# https://s2e.systems/docs/Tutorials/SystemTap/index.html
# https://sourceware.org/systemtap/documentation.html
#

%{
#include <linux/skbuff.h>

// struct DemoHeader {
//     uint8_t port; // egress port
//     uint8_t type; // packet type
// };
%}

#
# S2E functions.
# We use the embedded C support of SystemTap to access the S2E custom
# instructions. A comprehensive set of such instructions can be found in
# src/s2e/guest/common/include/s2e/s2e.h.
#

/**
 * Print a message to the S2E log.
 */
private function s2e_message(message:string) %{ /* unprivileged */
    __asm__ __volatile__(
        ".byte 0x0f, 0x3f\n"
        ".byte 0x00, 0x10, 0x00, 0x00\n"
        ".byte 0x00, 0x00, 0x00, 0x00\n"
        : : "a" (STAP_ARG_message));
%}

/**
 * Set the packet frame memory region to be symbolic in the skb_buff pointed to
 * by pskb.
 *
 * References:
 *   src/s2e/guest/common/include/s2e/s2e.h
 *   src/s2e/guest/common/include/s2e/opcodes.h
 */
private function s2e_mimesis_kernel_recv(pskb:long) %{
    struct sk_buff **pskb = (struct sk_buff **)STAP_ARG_pskb;
    __asm__ __volatile__(
        ".byte 0x0F, 0x3F\n"
        ".byte 0x00, 0x99, 0x02, 0x00\n"
        ".byte 0x00, 0x00, 0x00, 0x00\n"
        : : "a" (*pskb) : "memory"
    );
%}

/**
 * Record the egress packet traces and terminate the execution path.
 *
 * References:
 *   src/s2e/guest/common/include/s2e/s2e.h
 *   src/s2e/guest/common/include/s2e/opcodes.h
 */
private function s2e_mimesis_kernel_send(intf:long, buffer:long, len:long) %{
    __asm__ __volatile__(
        ".byte 0x0F, 0x3F\n"
        ".byte 0x00, 0x99, 0x03, 0x00\n"
        ".byte 0x00, 0x00, 0x00, 0x00\n"
        : : "a" (STAP_ARG_intf), "c" (STAP_ARG_buffer), "d" (STAP_ARG_len) : "memory"
    );
%}


#
# Helper functions.
#

/**
 * Print the given message to both the standard output and S2E log.
 */
private function info(message:string) {
    printf("%s: [%s] %s\n", probefunc(), execname(), message);
    msg = sprintf("%s: [%s] %s\n", probefunc(), execname(), message);
    s2e_message(msg);
}

/**
 * Check whether the mac_header field of the given sk_buff is set.
 * https://elixir.bootlin.com/linux/v6.8.2/source/include/linux/skbuff.h#L2904
 */
private function skb_mac_header_was_set:long(skb:long) %{ /* pure */
    struct sk_buff *skb = (struct sk_buff *)STAP_ARG_skb;
    uint16_t mac_header = kread(&(skb->mac_header));
    STAP_RETURN(mac_header != (typeof(mac_header))~0U);
%}

/**
 * Get the Ethernet header of the given sk_buff.
 * https://elixir.bootlin.com/linux/v6.8.2/source/include/linux/skbuff.h#L2909
 */
private function skb_mac_header:long(skb:long) { /* pure */
    return @cast(skb, "sk_buff")->head + @cast(skb, "sk_buff")->mac_header;
}

/**
 * Check whether the given Ethernet address is magical.
 */
private function check_eth_addr:long(eth_addr:long) %{ /* pure */
    uint8_t id_mac[6] = { 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF };
    STAP_RETURN(memcmp((uint8_t *)STAP_ARG_eth_addr, id_mac, 6) == 0);
%}


#
# Ingress probes.
#

/**
 * static int __netif_receive_skb_core(
 *      struct sk_buff **pskb,
 *      bool pfmemalloc,
 *      struct packet_type **ppt_prev
 * );
 *
 * https://elixir.bootlin.com/linux/v6.8.2/source/net/core/dev.c#L5322
 *
 * NIC drivers call this function when they are ready to give the received
 * packet to the kernel. At this moment, `skb->data` points to the end of the
 * Ethernet header.
 * See: http://vger.kernel.org/~davem/skb_data.html
 *      https://www.makelinux.net/ldd3/chp-17-sect-10.shtml
 *      http://www.skbuff.net/skbbasic.html
 *
 * (struct sk_buff):
 * https://elixir.bootlin.com/linux/v6.8.2/source/include/linux/skbuff.h#L852
 */
probe kernel.function("__netif_receive_skb_core").return {
    s2e_mimesis_kernel_recv(@entry($pskb));
}


#
# Egress probes.
#

# probe kernel.function("dev_hard_start_xmit") {
#     msg = sprintf("dev_hard_start_xmit");
#     info(msg);
# }
#
# probe kernel.function("xmit_one") {
#     msg = sprintf("xmit_one");
#     info(msg);
# }
#
# probe kernel.function("netdev_start_xmit") {
#     msg = sprintf("netdev_start_xmit");
#     info(msg);
# }
#
# /**
#  * netdev_tx_t __netdev_start_xmit(
#  *      const struct net_device_ops *ops,
#  *      struct sk_buff *skb,
#  *      struct net_device *dev,
#  *      bool more
#  * );
#  *
#  * https://elixir.bootlin.com/linux/v4.9.3/source/include/linux/netdevice.h#L4042
#  *
#  * Kernel calls this function to invoke the corresponding NIC drivers to start
#  * transmitting packets.
#  *
#  * (struct sk_buff):
#  * https://elixir.bootlin.com/linux/v4.9.3/source/include/linux/skbuff.h#L633
#  * (struct net_device):
#  * https://elixir.bootlin.com/linux/v4.9.3/source/include/linux/netdevice.h#L1641
#  */
# probe kernel.function("__netdev_start_xmit") {
#     msg = sprintf("__netdev_start_xmit");
#     info(msg);
#
#     # if (!skb_mac_header_was_set($skb)) {
#     #     info("mac_header is not set. skipping the sk_buff...");
#     #     next; // returns immediately from the enclosing probe handler.
#     # }
#     #
#     # # s2e_kill_state(0, "Terminate at dev_hard_start_xmit...");
#     #
#     # eth_hdr = skb_mac_header($skb)
#     # eth_dst_addr = @cast(eth_hdr, "ethhdr")->h_dest;
#     # ethertype = ntohs(@cast(eth_hdr, "ethhdr")->h_proto);
#     #
#     # msg = sprintf("len=%d data_len=%d dev_if=%d head=%x eth_dst_addr=%x ethertype=%x data=%x eth_hdr=%x",
#     #     $skb->len, $skb->data_len, $skb->dev->ifindex, $skb->head,
#     #     eth_dst_addr, ethertype, $skb->data, eth_hdr);
#     # info(msg);
# }
#
# /**
#  * Accessing $skb at __netdev_start_xmit or netdev_start_xmit gives an error,
#  * although $skb is a parameter for both in kernel 6.8.2.
#  * Links that might be relevant to this:
#  * https://man7.org/linux/man-pages/man7/error::pass2.7stap.html
#  * https://bugzilla.redhat.com/show_bug.cgi?id=1734097
#  *
#  * Therefore I am probing xmit_one:
#  * static int xmit_one(struct sk_buff *skb, struct net_device *dev, struct
#  * netdev_queue *txq, bool more)
#  */
#
# # probe kernel.function("xmit_one") {
# #     // eth_hdr = skb_mac_header($skb);
# #     // eth_dst_addr = @cast(eth_hdr, "ethhdr")->h_dest;
# #     // ethertype = ntohs(@cast(eth_hdr, "ethhdr")->h_proto);
# #
# #     ifindex_ptr = &$skb->dev->ifindex;
# #     msg = sprintf("xmit_one");
# #     info(msg);
# #     msg = sprintf("len=%d head=%x header_len=%d data=%x data_len=%d mac=%x mac_len=%d",$skb->len, $skb->head, $skb->hdr_len, $skb->data, $skb->data_len, $skb->mac_header, $skb->mac_len);
# #     info(msg);
# #     s2e_mimesis_kernel_send(ifindex_ptr, $skb->data, $skb->len);
# # }

# vim: ts=4 sw=4 et cms=#%s :
