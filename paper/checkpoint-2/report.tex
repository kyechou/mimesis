%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Template for USENIX papers.
%
% History:
%
% - TEMPLATE for Usenix papers, specifically to meet requirements of
%   USENIX '05. originally a template for producing IEEE-format
%   articles using LaTeX. written by Matthew Ward, CS Department,
%   Worcester Polytechnic Institute. adapted by David Beazley for his
%   excellent SWIG paper in Proceedings, Tcl 96. turned into a
%   smartass generic template by De Clarke, with thanks to both the
%   above pioneers. Use at your own risk. Complaints to /dev/null.
%   Make it two column with no page numbering, default is 10 point.
%
% - Munged by Fred Douglis <douglis@research.att.com> 10/97 to
%   separate the .sty file from the LaTeX source template, so that
%   people can more easily include the .sty file into an existing
%   document. Also changed to more closely follow the style guidelines
%   as represented by the Word sample file.
%
% - Note that since 2010, USENIX does not require endnotes. If you
%   want foot of page notes, don't include the endnotes package in the
%   usepackage command, below.
% - This version uses the latex2e styles, not the very ancient 2.09
%   stuff.
%
% - Updated July 2018: Text block size changed from 6.5" to 7"
%
% - Updated Dec 2018 for ATC'19:
%
%   * Revised text to pass HotCRP's auto-formatting check, with
%     hotcrp.settings.submission_form.body_font_size=10pt, and
%     hotcrp.settings.submission_form.line_height=12pt
%
%   * Switched from \endnote-s to \footnote-s to match Usenix's policy.
%
%   * \section* => \begin{abstract} ... \end{abstract}
%
%   * Make template self-contained in terms of bibtex entires, to allow
%     this file to be compiled. (And changing refs style to 'plain'.)
%
%   * Make template self-contained in terms of figures, to
%     allow this file to be compiled.
%
%   * Added packages for hyperref, embedding fonts, and improving
%     appearance.
%
%   * Removed outdated text.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[letterpaper,twocolumn,10pt]{article}
\usepackage{usenix2019_v3}

% to be able to draw some self-contained figs
\usepackage{tikz}
\usepackage{amsmath}

% inlined bib file
\usepackage{filecontents}

%-------------------------------------------------------------------------------
\begin{document}
%-------------------------------------------------------------------------------

%don't want date printed
\date{}

% make title bold and 14 pt font (Latex default is non-bold, 16 pt)
\title{\Large \bf Nekton: Middlebox Analysis for Network Verification\\
CS 523 Checkpoint 2 Project Report}

%for single author (just remove % characters)
\author{
{\rm Kuan-Yen Chou}
\qquad
{\rm Bin-Chou Kao}\\
University of Illinois at Urbana-Champaign
% copy the following lines to add more authors
% \and
% {\rm Name}\\
%Name Institution
} % end author

\maketitle

%-------------------------------------------------------------------------------
\begin{abstract}
%-------------------------------------------------------------------------------
%Your abstract text goes here. Just a few facts. Whet our appetites.
%Not more than 200 words, if possible, and preferably closer to 150.
In this report, we present the current progress and changes on the Nekton
project about middlebox analysis, current design of analysis procedure,
experiment, and the challenges we have encountered.
\end{abstract}


%-------------------------------------------------------------------------------
\section{Introduction}
%-------------------------------------------------------------------------------

% problem statement, goal
Let's briefly recapitulate the problems and the goal of this project. As we
know, middleboxes play a special role in many enterprise and data center
networks, where they typically keep states of the passing connections, and can
perform various actions based on the implementation, which makes it more
difficult to verify the correctness of a given network. So in this project, we
plan to analyze some given middleboxes so as to make it easier to verify such
networks. The goal for this course project is to try to explore all the
non-deterministic actions given a middlebox and an input.

% elaborate on non-determinism
Specifically, we use the term non-deterministic behaviors/actions to describe
the operations of middleboxes that normally would not be captured by a generic
stateless model based purely on L3 or L2 forwarding tables. For instance, some
load balancers would make routing decisions based on some temporal properties
(e.g., round-robin, time-based randomization, etc.), or server side properties
(e.g., least-connection first, server prioritization, etc.). Capturing these
non-deterministic behaviors is essentially equivalent to building an accurate
enough model describing the actual program. For verification of such cases,
therefore, we would like to know (1) what the set of possible actions is given
an input request, and (2) what the set of inputs (or combinations of relevant
input parameters) is that would lead to a given result action.

% briefly describe why we implement our own example software
However, it is not a trivial task to analyze complicated software binaries and
to get the desire information, which we will elaborate more in detail in the
following section. For the course project, we build a simple and yet
functionally realistic load balancer as a straw man example and a proof of
concept, which will be used to evaluate the viability and baseline performance
of the approach.


%-------------------------------------------------------------------------------
\section{Current Progress and Challenges}
%-------------------------------------------------------------------------------

\subsection{Assumptions on middleboxes}

% describe the middleboxes implementation (connection terminating and
% forwarding)
After the survey of various open source middleboxes, we observed that, in
general, the middleboxes can be categorized into two classes. One of them is the
middleboxes that would forward the transport layer header (assuming that the
end-to-end application is based on some connection-oriented protocol, like TCP),
such as NetFilter subsystem in Linux and its derivative utilities (e.g.,
iptables, nftables). These middleboxes might still forward packets to different
next hops or modify the packet headers, but they will not modify the packets so
that it breaks the transport layer connection between the client and the server.
A common example is using iptables to configure the NetFilter subsystem as a
firewall and/or NAT, in which case the layer 2 and layer 3 headers are modified,
but layer 4 header fields remain untouched. The other category consists of the
middleboxes that terminate the incoming connection at one end and start a new
connection to the backend server at another. Such middleboxes usually act as a
proxy or gateway, such as TCP proxies, HTTP proxies, SOCKS proxies (layer 5),
etc. To simplify the problem, we will only focus on the second kind of
middleboxes, which would accept/terminate the incoming connection and initiate a
new one, so that we treat each connection as request and reply application-layer
packets.

\subsection{Challenges and design of example middlebox}

% explain why it's hard to analyze such implementations
%   function pointers, event-driven, modular design, multi-threading
To analyze a given middlebox software binary, however, can be quite challenging
for several reasons. One major reason is that many of these production-grade
middlebox software are highly optimized in order to achieve high performance
within software and hence drastically increase the complexity of binary
analysis, and oftentimes these optimizations do not affect the eventual routing
behavior. For example, we looked into the implementation of HAProxy, which is
both a TCP proxy and an HTTP proxy depending on the configuration. The
implementation is highly modularized, object-oriented (function pointers),
event-driven, and multi-threaded, so that it is difficult to figure out where
the routing decision logic happens in the program, track how the variables and
data structures are passed, and localize the caller of a certain function. While
looking at the source code, we identified the part where they accept the
incoming connections, but we couldn't track the returned data structures without
decent documentations or the help of binary analysis tools.

% why we build our own implementation of example middlebox
% design overview of the example middlebox
In addition, since we are trying to analyze the binaries for the sake of
verifying the functional behavior of the middleboxes rather than their
performance, we implemented our own version of a load balancer prototype with
essential functionalities but without performance optimizations, so as to
simplify the analysis. The simple load balancer prototype currently supports
basic TCP load balancing schemes like round-robin and least-connection-first,
and we plan to add more interesting load balancing algorithms in the future,
possibly source-based hashing, HTTP URL hashing, etc. The middlebox prototype
follows the typical POSIX network application implementation. It first opens up
a socket, binds, and listens at the port. Once a connection is accepted, it then
forks a child process for the connection and keeps the states of both the
connections and the pre-configured backend servers. The forked child processes
will then act as proxies and initiate connections to the actual servers based on
the load balancing schemes mentioned above. The prototype will be used as a
straw man example and a proof of concept. If it goes well and time permits, we
will then move on to more complicated middlebox implementations.

\subsection{Binary analysis tools and analysis procedure}

% explain that we don't have time to learn bap and ocaml in this course
% so we chose angr for now.
We mentioned in the previous report that we were looking at binary analysis
tools like BAP and angr. However, after spending a few weeks on BAP, we think
that, for this course project, we don't really have that much time to learn a
new programming language (OCaml) for BAP, and without a good understanding of
the language, it is impossible to understand their documentations or APIs. As a
result, we will only focus on angr, which is written in Python, for the course
project, although BAP seems to have better performance. We may explore more
about BAP and learn OCaml properly after this course.

% describe what we did with bap and angr: CFG, CG
For BAP, we have explored a few of its core functions, such as constructing a
CFG (control flow graph) and a CG (call graph) given a program binary. Control
flow graph is a directed graph where each node is a code block of sequential
instructions without branches, except for the beginning and the end of the
block, and each edge is a branch from one block to another. Call graph,
nonetheless, is a directed graph consisting of code blocks of functions with
edges being function calls or returning to the caller function. For angr, we
have tried a few CFG generation APIs, but they do not really a independent API
for call graph. Rather, we would need to generate the CFG first, and then use
the \texttt{cfg.function\_manager.callgraph} API to extract the call graph.

% overview of analysis procedure, solver engine
The CFGs and CGs of the binaries are important and helpful for middlebox binary
analysis in that we need to localize the calling instructions of a given system
call. To achieve that, we first traverse through the call graph from the entry
point, and find if there is the calling instruction in each node (code block).
Once we found the calling instruction(s) and the caller function of the target
system call (e.g., accept), the next step is to find the relevant variables
containing desired information. In our example case, that would be the client IP
address, TCP port number, and payload, which may contain the HTTP header. Those
variables, in the lower assembly or intermediate representation (IR) level, can
either be as registers or memory locations. We would create corresponding
variables in angr's solver engine with appropriate symbolic values and concrete
values as constrains. The solver engine will then try to solve and evaluate the
symbolic values according to the set constrains.


\subsection{Future challenges}

% future challenges: function pointer, need of program specific knowledge
In the future, we plan to finish the implementation of the whole analysis
procedure, and possibly automating it. However, a main challenge of our work is
the fact that in order to do analysis, we still need to assume some level of
understanding of the target program implementation, such as the system call APIs
the program uses, and fully automation without prior knowledge remains very
difficult, if not impossible, at this stage. Another challenge would be dynamic
behavior of the program, such as function pointers that cannot be determined
statically. Though it may be possible to inject concrete values to some
variables to the program through angr and to get the concrete values of those
function pointers, it would definitely increase the complexity of the analysis.


%%-------------------------------------------------------------------------------
%\section{Design and Methods}
%%-------------------------------------------------------------------------------
%
%\subsection{Binary Ananlysis with Angr}
%%-----------------------------------
%
%% intro to angr, its abilities
%%   CFG, block, node
%%   CFG traversal
%%   looking for specific instruction (like certain function call) in a block
%%   looking for variables (either in registers or memory)
%%   symbolic solver engine
%% how we plan to use angr for binary analysis
%
%\subsection{Example: Simple Load Balancer}
%%-----------------------------------
%
%% design overview:
%% classic listen, accept, fork, wait; connection endpoints proxying
%As mentioned above, we have a simplified implementation of a load balancer
%middlebox,
%
%% load-balancing schemes
%% how we keep states of connections and servers
%
%\subsection{Experiment}
%%-----------------------------------
%
%% goal?
%% scenario description
%% evaluation


%-------------------------------------------------------------------------------
%\section*{Acknowledgments}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
%\section*{Availability}
%-------------------------------------------------------------------------------

%USENIX program committees give extra points to submissions that are
%backed by artifacts that are publicly available. If you made your code
%or data available, it's worth mentioning this fact in a dedicated
%section.

%-------------------------------------------------------------------------------
%\bibliographystyle{plain}
%\bibliography{\jobname}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%  LocalWords:  endnotes includegraphics fread ptr nobj noindent
%%  LocalWords:  pdflatex acks
