%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Template for USENIX papers.
%
% History:
%
% - TEMPLATE for Usenix papers, specifically to meet requirements of
%   USENIX '05. originally a template for producing IEEE-format
%   articles using LaTeX. written by Matthew Ward, CS Department,
%   Worcester Polytechnic Institute. adapted by David Beazley for his
%   excellent SWIG paper in Proceedings, Tcl 96. turned into a
%   smartass generic template by De Clarke, with thanks to both the
%   above pioneers. Use at your own risk. Complaints to /dev/null.
%   Make it two column with no page numbering, default is 10 point.
%
% - Munged by Fred Douglis <douglis@research.att.com> 10/97 to
%   separate the .sty file from the LaTeX source template, so that
%   people can more easily include the .sty file into an existing
%   document. Also changed to more closely follow the style guidelines
%   as represented by the Word sample file.
%
% - Note that since 2010, USENIX does not require endnotes. If you
%   want foot of page notes, don't include the endnotes package in the
%   usepackage command, below.
% - This version uses the latex2e styles, not the very ancient 2.09
%   stuff.
%
% - Updated July 2018: Text block size changed from 6.5" to 7"
%
% - Updated Dec 2018 for ATC'19:
%
%   * Revised text to pass HotCRP's auto-formatting check, with
%     hotcrp.settings.submission_form.body_font_size=10pt, and
%     hotcrp.settings.submission_form.line_height=12pt
%
%   * Switched from \endnote-s to \footnote-s to match Usenix's policy.
%
%   * \section* => \begin{abstract} ... \end{abstract}
%
%   * Make template self-contained in terms of bibtex entires, to allow
%     this file to be compiled. (And changing refs style to 'plain'.)
%
%   * Make template self-contained in terms of figures, to
%     allow this file to be compiled.
%
%   * Added packages for hyperref, embedding fonts, and improving
%     appearance.
%
%   * Removed outdated text.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[letterpaper,twocolumn,10pt]{article}
\usepackage{usenix2019_v3}

% to be able to draw some self-contained figs
\usepackage{tikz}
\usepackage{amsmath}

% inlined bib file
\usepackage{filecontents}

%-------------------------------------------------------------------------------
\begin{document}
%-------------------------------------------------------------------------------

%don't want date printed
\date{}

% make title bold and 14 pt font (Latex default is non-bold, 16 pt)
\title{\Large \bf Nekton: Middlebox Analysis for Network Verification\\
CS 523 Checkpoint 1 Project Report}

%for single author (just remove % characters)
\author{
{\rm Kuan-Yen Chou}
\qquad
{\rm Bin-Chou Kao}\\
University of Illinois at Urbana-Champaign
% copy the following lines to add more authors
% \and
% {\rm Name}\\
%Name Institution
} % end author

\maketitle

%-------------------------------------------------------------------------------
\begin{abstract}
%-------------------------------------------------------------------------------
%Your abstract text goes here. Just a few facts. Whet our appetites.
%Not more than 200 words, if possible, and preferably closer to 150.
In this report, we present the current progress on the Nekton project about
middlebox analysis and the challenges we have encountered.
\end{abstract}


%-------------------------------------------------------------------------------
\section{Introduction}
%-------------------------------------------------------------------------------

Let's briefly recapitulate the problems and the goal of this project. As we
know, middleboxes play a special role in many enterprise or data center
networks, where they typically keep states of the related connections, and can
perform various actions based on the implementation, which makes it more
difficult to verify the correctness of the a given network. So in this project,
we plan to analyze some given middleboxes so as to make it easier to verify such
networks. The goal for this course project is to try to explore all the
non-deterministic actions given a middlebox and an input.


%-------------------------------------------------------------------------------
\section{Current Progress and Challenges}
%-------------------------------------------------------------------------------

So far, we have done some survey on common open source middleboxes, including
HAProxy, Nginx, and Snort. HAProxy and Nginx are typically used as reverse
proxies, where they sit somewhere in the network near the actual servers, serve
the requests on behave of them, and then balance the traffic across the set of
backend servers according to some internal heuristics. Snort is an intrusion
detection and prevention system (IDS/IPS), which is usually placed near a
firewall as an additional protection for untrusted traffic. In this project, we
will only focus on its IPS mode, where it will potentially drop or modify
packets, instead of IDS mode, where it only detects and analyzes the traffic.

The difference between HAProxy and Nginx is that Nginx is an HTTP proxy, an L7
load balancer, which can act based on the HTTP header, while HAProxy can be
configured either as an L7 load balancer, or as an L4 load balancer acting only
on the IP/TCP headers. A L7 load balancer may be a challenging issue for our
goal. Since most verification frameworks or middlebox abstraction techniques
only model the traffic up to the transport layer, so we may not be able to model
some certain middlebox behaviors that are based on L7 header content.

One of the common behaviors we found is that many of these load balancing
proxies would usually terminate or accept the request connections and then
initiate another connection to the backend server, which is different from
the common firewalls that simply forward or drop the packets. This behavior
seems to complicate the computation of PECs, but it actually does not. We can
still compute the PEC based on the 5-tuple. Another common behavior is that many
of these middleboxes implement the decision logic and handle the connections in
userspace, instead of inserting filtering or routing entries in the kernel,
which is good news, since it is more convincing for us to examine the middlebox
binaries.

In addition to studying the middleboxes, we are currently focusing on a program
analysis tool called BAP (Binary Analysis Platform) by CMU, going through their
documentation, and writing analysis code based on their public APIs. Some other
students are looking into another tool called angr, but they are not enrolled in
this course. BAP is a program analysis platform written in OCaml, but also comes
with Python and C binding libraries. It basically disassembles the binary code
and lifts it into their own RISC-like BAP Instruction Language (BIL)
representation, on which program analysis is performed.

One challenge is the internal load balancing schemes. Take HAProxy for example.
HAProxy has implementation of many load balancing algorithms. Some of them are
deterministic in a sense that given the same input packet, the result action
will always to be the same, such as source-based hashing. But some of them are
non-deterministic in a sense that the root cause of the different result actions
is not modelled, which can be the L7 HTTP header, like URI-based hashing, or the
state of the backend servers, like least-connection-based load balancing. So
given that we plan to use the 5-tuple model for the packet space, we would need
binary analysis to find all the "non-modelled" non-deterministic result actions.

Another main challenge is the performance and scalability in terms of the
program size. We tried using BAP on the binary executable of HAProxy, which is
about 2.1 MB, and it took about 1.5 minutes to parse and load the binary code
into their internal representation. The second time doing the same thing took
about 30 to 40 seconds. The baseline here sounds okay, but it may be an issue
for some big binaries.


%-------------------------------------------------------------------------------
%\section{Methods}
%-------------------------------------------------------------------------------

%\subsection{}
%-----------------------------------

%-------------------------------------------------------------------------------
%\section*{Acknowledgments}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
%\section*{Availability}
%-------------------------------------------------------------------------------

%USENIX program committees give extra points to submissions that are
%backed by artifacts that are publicly available. If you made your code
%or data available, it's worth mentioning this fact in a dedicated
%section.

%-------------------------------------------------------------------------------
%\bibliographystyle{plain}
%\bibliography{\jobname}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%  LocalWords:  endnotes includegraphics fread ptr nobj noindent
%%  LocalWords:  pdflatex acks
