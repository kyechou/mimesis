%-------------------------------------------------------------------------------
\section{Introduction}
%-------------------------------------------------------------------------------

% background
Networks play an essential role in modern computing systems, many of which are
interconnected and administered by various organizations and institutions. With
the core architecture and protocols being devised in the 1990s and early 2000s,
it has been a challenging yet important task to efficiently and effectively
manage the legacy/traditional networks without causing any serious outages
\footnote{In this paper, we use the terms "legacy networks" and "traditional
networks" interchangeably, in contrast to the newer implementations of
software-defined networks (SDN). Nonetheless, the middlebox analysis techniques
should not be limited to any certain kinds of networks.}, since a minor
configuration error by human operators can potentially affect the behavior of
multiple networks, and even bring down customer-facing services on a global
scale \cite{2017-Newton,2018-Speed}. As a result, it would be extremely
beneficial if we are able to either formally verify or test the correctness of a
given network to some satisfactory extent.

% problem statement
In order to verify or test a given network, one of the biggest obstacles is the
existence of middleboxes. Middleboxes are special devices that are deployed
somewhere in a network for some complicated network functions, such as packet
processing, packet filtering, traffic engineering, or packet inspection. They
can be real appliances one bought from a device vendor, or distributed as
software running on other machines. Some common middleboxes are firewalls (FWs),
network address translators (NATs), load balancers (LBs), caching proxies, and
intrusion detection/prevention systems (IDS/IPS).

For verifying networks with middleboxes, it is very hard to automatically or
efficiently create accurate models for all kinds of these network functions
deployed in the networks. Plankton-neo \cite{2018-PrabhuEtAl} tried to solve the
problem by combining model-checking verification with emulation. However, in
Plankton-neo, for each execution path of a network system, the corresponding
representative packet of a packet equivalence class (PEC) is injected only once,
which does not provide sufficient coverage if a middlebox behaves
non-deterministically (i.e., for the same input stream, it has more than one
different possible actions). Some examples are load balancers and dynamic NATs.

In addition, even for a specific type of middleboxes, the implementations vary
across vendors and it is very likely that they contain bugs that are uncaught or
unfixed, given the highly specialized nature of these middleboxes. Unlike the
typical network protocols, where most of the implementations follow the
standardized practices and we can build models based on those standards, which
can be used for various devices that implement the same protocol, the
middleboxes and software network functions usually do not have these standards
that we can follow to build accurate models. The complexity of software network
functions also increases the likelihood of undiscovered bugs, which may lead to
network policy violations even when the network administrator has configured the
network components correctly. Since the behaviors of the middleboxes implemented
by different vendors vary and there may be bugs that affect the behaviors of the
middleboxes, it is impractical to build an individual, accurate, and
bug-faithful model for each middlebox implementation in reality.

% goal
Thus, in this project, we plan to analyze some given middleboxes so as to make
it easier to verify such networks. The goal is to find the mappings between the
input stream and the output stream given a middlebox, which is essentially a
compressed accurate model for the middlebox given the concrete configurations.
The model then can be used for verifying networks with the middlebox in
question, specifically for computer input packet equivalence classes and
possible outputs (i.e., routing decisions and packet modifications).


%-------------------------------------------------------------------------------
% vim: set ft=tex :
