%-------------------------------------------------------------------------------
\section{Design and Methods}
%-------------------------------------------------------------------------------

In this project, our goal is to find a mapping $f$ between the inputs and
outputs of a given middlebox, namely, $\forall$ input stream $s_i$, $\exists$
an output stream $s_o$, such that $s_o = f(s_i)$. In this section, we describe
how we design our approach of finding the output based on the provided input.


\subsection{Assumptions on middleboxes}
%-------------------------------------------------------------------------------

% describe the middleboxes implementation (connection terminating and
% forwarding)
After the survey of some open source middleboxes, we observed that, in general,
the middleboxes can be categorized into two classes. One of them is the
middleboxes that would simply forward the transport layer header without
terminating the transport layer connection (assuming that the end-to-end
application is based on some connection-oriented protocol, like TCP), such as
NetFilter subsystem in Linux and its derivative utilities (e.g., iptables,
nftables). These middleboxes might still forward packets to different next hops
or modify the packet headers, but they will not modify the packets so that it
breaks the transport layer connection between the client and the server. A
common example is using iptables to configure the NetFilter subsystem as a
firewall and/or NAT, in which case the layer 2 and layer 3 headers are modified,
but layer 4 header fields remain untouched. The other category consists of the
middleboxes that terminate the incoming connection at one end and start a new
connection to the backend server at another. Such middleboxes usually act as a
proxy or gateway, such as TCP proxies, HTTP proxies, SOCKS proxies (layer 5),
etc. To simplify the problem, we only focus on the second kind of middleboxes,
which accept and terminate the incoming connections and initiate a new one for
each connection.

Besides, we assume to have some level of understanding of the target program,
including the instruction set architecture of the program, network-related APIs
or libraries used, and the functions that take the inputs or decide the outputs.


\subsection{Binary ananlysis}
%-------------------------------------------------------------------------------

% intro to angr, its abilities
%   CFG, block, node
%   CFG traversal
%   looking for specific instruction (like certain function call) in a block
%   looking for variables (either in registers or memory)
%   symbolic solver engine
% how we plan to use angr for binary analysis

Since our goal is to get the potential output from the provided input, and also
the potential inputs that lead to some certain output, it is reasonable to use
symbolic execution with binary analysis tools.

The analysis procedure works as follows:
\begin{enumerate}
    \item Build the control flow graph and call graph of the target binary.
    \item Locate the instructions that call the function reading inputs or the
        function deciding outputs.
    \item Symbolically execute the program from the initial state.
    \item When the execution reaches and finishes the execution of the
        instruction that calls the function reading inputs, set the input
        relevant input variables to be symbolic values.
    \item Add constraints on the input variables if needed.
    \item Continue the execution until reaching and finishing the execution of
        the instruction that calls the function deciding outputs.
    \item Obtain the output, which should be arithmetic expressions with the
        input symbolic variables.
    \item Add constraints on the output variables if needed.
    \item Evaluate the output to get valid concrete values of the input and
        output that satisfy the expressions and constraints.
\end{enumerate}


%-------------------------------------------------------------------------------
% vim: set ft=tex :
