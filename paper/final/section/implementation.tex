%-------------------------------------------------------------------------------
\section{Implementation}
%-------------------------------------------------------------------------------

\subsection{Simple load balancer}
%-------------------------------------------------------------------------------

% why
While analyzing HAProxy, we found that it is difficult to identify the important
functions or APIs and which parts of the code may be irrelevant. So in order to
test our approach, we build a simple load balancer as a minimal working example
or a proof of concept for the binary analysis procedure.

% load balancing algorithms and socket API
The simple load balancer implements two common load balancing algorithms,
round-robin and source-based hashing. Round-robin keeps an internal counter
variable that is incremented by one whenever a connection is accepted, and
selects the backend server from an array of servers using the counter as the
decision index.  Source-based hashing, on the other hand, determines the backend
server based on the hash value of the source address of requests. The computed
hash value is mapped to the array of servers, so the same client will always
connect to the same server, no matter how many requests having been processed
over time. The load balancer is written on Linux and utilizes the BSD socket API
to receive connections and handle requests and responses.


\subsection{Binary analysis using angr}
%-------------------------------------------------------------------------------

% why angr
Since BAP is written and mostly used in OCaml, with which we are not familiar,
ane there are not much API documentations for other language bindings of BAP, it
is difficult for us to learn a new language to use BAP for middlebox analysis.
As a consequence, we decided to use angr for this job.

% locating an instruction
With angr, we essentially follow the approach described in the previous section,
except that when locating instructions, things get a bit more comlicated. In
order to locate a calling instruction, we first obtain the target function
object that is to be called (i.e., the functions that read inputs or make output
decisions, which are \texttt{accept} and \texttt{select\_server} in our simple
load balancer example), and also the function object that calls the target
function, which is \texttt{main} in our example, by using the generated call
graph and tracing for the parent functions. After getting the parent functions,
we access the control flow graphs of the local parent functions, where each node
in a control flow graph is a sequential instruction block without any branches
except at the beginning or the end of the block. Within each control flow graph,
we recursively explore all the node with in-order depth first search, and for
each node, we then examine the disassembled instructions in the block of that
node to see whether it is calling the target function. Detailed implementations
can be found at our code repository~\cite{nekton-repo}.


%-------------------------------------------------------------------------------
% vim: set ft=tex :
