
%-------------------------------------------------------------------------------
\section{Introduction}
%-------------------------------------------------------------------------------

% background
Networks play an essential role in modern computing systems, many of which are
interconnected and administered by various organizations and institutions. With
the core architecture and protocols being devised in the 1990s and early 2000s,
it has been a challenging yet important task to efficiently and effectively
manage the legacy/traditional networks without causing any serious outages
\footnote{In this paper, we use the terms "legacy networks" and "traditional
networks" interchangeably, in contrast to the newer implementations of
software-defined networks (SDN). Nonetheless, the middlebox analysis techniques
should not be limited to any certain kinds of networks.},
since a minor configuration error by a human operator can potentially affect the
behavior of multiple networks globally, which could cause serious financial
losses. As a result, it would be extremely beneficial if we are able to either
formally verify or test the correctness of a given network to some satisfactory
extent.

%problem statement
In order to verify or test a given network, one of the biggest obstacles is the
existence of middleboxes. Middleboxes are special devices that are deployed
somewhere in a network for some complicated network functions, such as packet
processing, packet filtering, traffic engineering, or packet inspection. They
can be real appliances one bought from a device vendor, or distributed as
software running on other machines. Some common middleboxes are firewalls (FWs),
network address translators (NATs), load balancers (LBs), caching proxies, and
intrusion detection/prevention systems (IDS/IPS).

For verifying networks with middleboxes, it is very hard to automatically or
efficiently create accurate models for all kinds of middleboxes. Plankton-neo
\cite{2018-PrabhuEtAl} tried to solve the problem by combining model-checking
verification with emulation. However, in Plankton-neo, for each execution path
of a network system, the corresponding representative packet of a packet
equivalence class (PEC) is injected only once, which does not provide sufficient
coverage if a middlebox behaves non-deterministically (i.e. for the same input
packet, it has more than one different possible actions, without internal state
changes). Some examples are load balancers and dynamic NATs. In addition, the
PECs are computed from the configurations of the middleboxes and other nodes,
which is not ideal in practice for two reasons. One is that it is very likely
that we don't have a formal specification of how a middlebox works in detail.
The other reason is that even if we have a detailed, formal specification of a
middlebox, it is highly probable that there are implementation bugs in the
software.
% goal
Thus, in this project, we plan to analyze some given middleboxes so as to make 
it easier to verify such networks. The goal is to explore all the non-deterministic 
actions given a middlebox and an input.

