%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Template for USENIX papers.
%
% History:
%
% - TEMPLATE for Usenix papers, specifically to meet requirements of
%   USENIX '05. originally a template for producing IEEE-format
%   articles using LaTeX. written by Matthew Ward, CS Department,
%   Worcester Polytechnic Institute. adapted by David Beazley for his
%   excellent SWIG paper in Proceedings, Tcl 96. turned into a
%   smartass generic template by De Clarke, with thanks to both the
%   above pioneers. Use at your own risk. Complaints to /dev/null.
%   Make it two column with no page numbering, default is 10 point.
%
% - Munged by Fred Douglis <douglis@research.att.com> 10/97 to
%   separate the .sty file from the LaTeX source template, so that
%   people can more easily include the .sty file into an existing
%   document. Also changed to more closely follow the style guidelines
%   as represented by the Word sample file.
%
% - Note that since 2010, USENIX does not require endnotes. If you
%   want foot of page notes, don't include the endnotes package in the
%   usepackage command, below.
% - This version uses the latex2e styles, not the very ancient 2.09
%   stuff.
%
% - Updated July 2018: Text block size changed from 6.5" to 7"
%
% - Updated Dec 2018 for ATC'19:
%
%   * Revised text to pass HotCRP's auto-formatting check, with
%     hotcrp.settings.submission_form.body_font_size=10pt, and
%     hotcrp.settings.submission_form.line_height=12pt
%
%   * Switched from \endnote-s to \footnote-s to match Usenix's policy.
%
%   * \section* => \begin{abstract} ... \end{abstract}
%
%   * Make template self-contained in terms of bibtex entires, to allow
%     this file to be compiled. (And changing refs style to 'plain'.)
%
%   * Make template self-contained in terms of figures, to
%     allow this file to be compiled.
%
%   * Added packages for hyperref, embedding fonts, and improving
%     appearance.
%
%   * Removed outdated text.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[letterpaper,twocolumn,10pt]{article}
\usepackage{usenix2019_v3}

% to be able to draw some self-contained figs
\usepackage{tikz}
\usepackage{amsmath}

% inlined bib file
\usepackage{filecontents}

%-------------------------------------------------------------------------------
\begin{document}
%-------------------------------------------------------------------------------

%don't want date printed
\date{}

% make title bold and 14 pt font (Latex default is non-bold, 16 pt)
\title{\Large \bf CS 523 Project Proposal:\\
Middlebox Analysis for Network Verification}

%for single author (just remove % characters)
\author{
{\rm Kuan-Yen Chou}
\qquad
{\rm Bin-Chou Kao}\\
University of Illinois at Urbana-Champaign
% copy the following lines to add more authors
% \and
% {\rm Name}\\
%Name Institution
} % end author

\maketitle

%-------------------------------------------------------------------------------
%\begin{abstract}
%-------------------------------------------------------------------------------
%Your abstract text goes here. Just a few facts. Whet our appetites.
%Not more than 200 words, if possible, and preferably closer to 150.
%\end{abstract}


%-------------------------------------------------------------------------------
\section{Introduction and Background}
%-------------------------------------------------------------------------------

Networks play an essential role in modern computing systems, many of which are
interconnected and administered by various organizations and institutions. With
the core architecture and protocols being devised in the 1990s and early 2000s,
it has been a challenging yet important task to efficiently and effectively
manage the legacy/traditional networks without causing any serious outages
\footnote{In this paper, we use the terms "legacy networks" and "traditional
networks" interchangeably, in contrast to the newer implementations of
software-defined networks (SDN). Nonetheless, the middlebox analysis techniques
should not be limited to any certain kinds of networks.},
since a minor configuration error by a human operator can potentially affect the
behavior of multiple networks globally, which could cause serious financial
losses. As a result, it would be extremely beneficial if we are able to either
formally verify or test the correctness of a given network to some satisfactory
extent.

In order to verify or test a given network, one of the biggest obstacles is the
existence of middleboxes. Middleboxes are special devices that are deployed
somewhere in a network for some complicated network functions, such as packet
processing, packet filtering, traffic engineering, or packet inspection. They
can be real appliances one bought from a device vendor, or distributed as
software running on other machines. Some common middleboxes are firewalls (FWs),
network address translators (NATs), load balancers (LBs), caching proxies, and
intrusion detection/prevention systems (IDS/IPS).

For verifying networks with middleboxes, it is very hard to automatically or
efficiently create accurate models for all kinds of middleboxes. Plankton-neo
\cite{2018-PrabhuEtAl} tried to solve the problem by combining model-checking
verification with emulation. However, in Plankton-neo, for each execution path
of a network system, the corresponding representative packet of a packet
equivalence class (PEC) is injected only once, which does not provide sufficient
coverage if a middlebox behaves non-deterministically (i.e. for the same input
packet, it has more than one different possible actions, without internal state
changes). Some examples are load balancers and dynamic NATs. In addition, the
PECs are computed from the configurations of the middleboxes and other nodes,
which is not ideal in practice for two reasons. One is that it is very likely
that we don't have a formal specification of how a middlebox works in detail.
The other reason is that even if we have a detailed, formal specification of a
middlebox, it is highly probable that there are implementation bugs in the
software.

%which does not account for run-time state changes (caused by packet traversal),
%so that people had to apply domain knowledge to design sensible policies
%according to the middlebox, and use it to compute new PEC(s) at run time. For
%example, for common stateful firewalls, we know that the affected new PEC of a
%request packet (consider a L7 http packet for instance) or a request connection
%is the reply packets. For reverse cache servers, we know that the affected new
%PEC is the same as the PEC that caused previous cache miss. It is very likely
%that the middleboxes are implemented differently from what we thought, and may
%even have bugs. That's why we want to derive the sequences of related PECs from
%the actual middleboxes rather than our assumptions.


%-------------------------------------------------------------------------------
\section{Problems and Methods}
%-------------------------------------------------------------------------------

To summarize, the problems and the proposed plans are
\footnote{In this project, we assume that we are already in possession of the
binary executables and the configuration files needed to instantiate the
middleboxes in the network.}:

\begin{enumerate}
\item \textit{\textbf{How do we explore all the non-deterministic actions of a
    middlebox with a given input (a PEC)?}}\\
        Given the binary and configuration files of a middlebox, We plan to
        first utilize some existing binary analysis and symbolic execution tools
        (including but not limited to KLEE, angr, and BAP), explore their
        abilities and limitations, and then find a way to integrate with or
        modify for our middlebox analysis system. The expected result is a set
        of possible actions taken by the middlebox with the input.
\item \textit{\textbf{Which PECs, or sequences of PECs, will make the middlebox
    behave differently?}} \cite{2017-PandaEtAl}\\
        This problem is expected to be much harder, because, in order to get the
        answer, theoretically we would need to know, or test, every combination
        of all the different PECs, which in turn need the results from the first
        problem. Similarly, we plan to utilize the existing symbolic execution
        techniques, inject the representative packets of corresponding PECs, and
        then observe the set of result actions.
        \footnote{In this course, we will mostly focus on the first problem,
        design some concrete scenarios, solve the problem for those common
        middleboxes first, and then generalize and automate the analysis
        process.}
\end{enumerate}


%-------------------------------------------------------------------------------
%\section{Methods}
%-------------------------------------------------------------------------------

%\subsection{}
%-----------------------------------

%-------------------------------------------------------------------------------
%\section*{Acknowledgments}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
%\section*{Availability}
%-------------------------------------------------------------------------------

%USENIX program committees give extra points to submissions that are
%backed by artifacts that are publicly available. If you made your code
%or data available, it's worth mentioning this fact in a dedicated
%section.

%-------------------------------------------------------------------------------
\bibliographystyle{plain}
\bibliography{\jobname}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%  LocalWords:  endnotes includegraphics fread ptr nobj noindent
%%  LocalWords:  pdflatex acks
